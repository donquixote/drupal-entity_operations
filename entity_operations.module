<?php
/**
 * @file entity_operations.module
 * Contains API functions and core hooks for the Entity Operations module.
 */

/**
 * Get the content for an entity's operation.
 *
 * This allows, for instance, a particular operation form to be embedded in
 * another context.
 *
 * @param $entity_type
 *  The entity type.
 * @param $entity
 *  The entity to return the operation for.
 * @param $operation
 *  The name of the operation. This should be the key of an item in the entity
 *  type's operation array.
 *
 * @return
 *  The content for the operation (page content or a form), or NULL if access
 *  to the operation is denied.
 */
function entity_operations_get_operation($entity_type, $entity, $operation) {
  $entity_info = entity_get_info($entity_type);

  if (isset($entity_info['operations ui']['operations'][$operation])) {
    $operation_class = $entity_info['operations ui']['operations'][$operation]['handler'];

    $operation_handler = new $operation_class($entity_type);

    // Check access for the operation.
    if ($operation_handler->operationAccess($entity_type, $entity) === FALSE) {
      return;
    }
    if ($operation_handler->userAccess($entity_type, $entity) === FALSE) {
      return;
    }

    $operation_info = $operation_handler->operationInfo();
    if ($operation_info['uses form']) {
      return drupal_get_form('entity_operations_operation_form', $entity_type, $operation_class, $operation, $entity);
    }
    else {
      return $operation_handler->page();
    }
  }
}

/**
 * Helper to output operations in an entity's content.
 *
 * This can be used in an entity class's buildContent() thus:
 * @code
 *  $build['operations'] = entity_operations_get_entity_operations_fieldset($this, array('publish', 'unpublish'));
 * @code
 *
 * @param $entity
 *  The entity to get operations for. This must be a subclass of Entity.
 * @param $operations
 *  (Optional) An array of operation names. These are the keys defined in the
 *  operations array in the entity's hook_entity_info(). If ommitted, the
 *  operations used are those with 'entity view' set to TRUE in their
 *  hook_entity_info() definition.
 *
 * @return
 *  A build array containing all the requested entities, or an empty array
 *  if no operations are available.
 */
function entity_operations_get_entity_operations_fieldset($entity, $operations = array()) {
  $entity_type = $entity->entityType();

  // Build up operations array if it's empty.
  if (empty($operations)) {
    $entity_info = $entity->entityInfo();
    foreach ($entity_info['operations ui']['operations'] as $operation_path => $operation_definition) {
      if (isset($operation_definition['entity view'])) {
        $operations[] = $operation_path;
      }
    }
  }

  $build = array(
    '#type' => 'fieldset',
    '#title' => t('Operations'),
  );

  $build_operations = array();
  foreach ($operations as $operation) {
    $operation_form = entity_operations_get_operation($entity_type, $entity, $operation);
    // This may be NULL if access is not allowed.
    if (!isset($operation_form)) {
      continue;
    }

    // Remove the confirmation question.
    unset($operation_form['question']);

    $build_operations[$operation] = $operation_form;
  }

  if (!empty($build_operations)) {
    $build['operations'] = $build_operations;
    return $build;
  }
  // Return an empty array if there are no operations allowed.
  return array();
}

/**
 * Get the operations for all entities.
 *
 * @todo: upgrade this to use caching?
 * @todo: refactor all other code so we always go via here, which would make
 * changing the hook easier.
 *
 * @return
 *  An array of entity operation info, keyed by entity type. The array values
 *  are the same as returned by hook_entity_info().
 *
 * @see entity_operations_hook_entity_info()
 */
function entity_operations_get_operation_info() {
  $operation_info = array();
  foreach (entity_get_info() as $entity_type => $entity_info) {
    if (isset($entity_info['operations ui'])) {
      $operation_info[$entity_type] = $entity_info['operations ui'];
    }
  }
  return $operation_info;
}

/**
 * Implements hook_menu().
 */
function entity_operations_menu() {
  $items = array();
  foreach (entity_get_info() as $entity_type => $info) {
    if (isset($info['operations ui'])) {
      $class = isset($info['operations ui']['controller class']) ? $info['operations ui']['controller class'] : 'EntityOperationsDefaultUIController';
      $controller = new $class($entity_type, $info);
      $items += $controller->hook_menu();
    }
  }

  return $items;
}

/**
 * Generic entity URI callback.
 *
 * This can be used for any entity that uses Entity Operations. It will return
 * the path to the default entity operation, consisting of entity base path
 * defined in $entity_info['operations ui']['path'] with the entity ID appended.
 */
function entity_operations_entity_uri($entity) {
  // Rely on our entity classes being at least Entity, which means we can
  // get a type out of them. Haha!
  $entity_info = $entity->entityInfo();
  $path = $entity_info['operations ui']['path'] . '/' . $entity->identifier();
  return array('path' => $path);
}

/**
 * Generic page callback. Hands over to the handler's page() method.
 *
 * @param $entity_type
 *  The entity type.
 * @param $handler_class
 *  The name of the handler class for the current operation.
 * @param $entity
 *  The entity.
 *
 * @return
 *  Either output text or a render array.
 */
function entity_operations_operation_page_callback($entity_type, $handler_class, $entity) {
  // Set the title to the entity so operation handlers don't have to.
  drupal_set_title($entity->label());

  $operation_handler = new $handler_class($entity_type);

  return $operation_handler->page($entity_type, $entity);
}

/**
 * Operation form callback. Hands over to the handler's form() method.
 */
function entity_operations_operation_form($form, &$form_state, $entity_type, $handler_class, $operation_path, $entity) {
  // Set the title to the entity so operation handlers don't have to.
  drupal_set_title($entity->label());

  $operation_handler = new $handler_class($entity_type);

  return $operation_handler->form($form, $form_state, $entity_type, $entity, $operation_path);
}

/**
 * Operation form validate callback. Hands over to the handler's formValidate().
 */
function entity_operations_operation_form_validate($form, &$form_state) {
  list($entity_type, $handler_class, $operation_path, $entity) = $form_state['build_info']['args'];

  $operation_handler = new $handler_class($entity_type);

  $operation_handler->formValidate($form, $form_state, $entity_type, $entity, $operation_path);
}

/**
 * Operation form submit callback. Hands over to the handler's formSubmit().
 */
function entity_operations_operation_form_submit($form, &$form_state) {
  list($entity_type, $handler_class, $operation_path, $entity) = $form_state['build_info']['args'];

  $operation_handler = new $handler_class($entity_type);

  $operation_handler->formSubmit($form, $form_state, $entity_type, $entity, $operation_path);
}

/**
 * Menu access callback for an operation.
 *
 * This first checks the handler's operationAccess() for a basic sanity check
 * and then passes on to entity_access() using the operation's verb as the $op
 * to check access for.
 */
function entity_operations_operation_access_callback($entity_type, $handler_class, $entity) {
  // First see whether the handler has anything to say about access from a
  // purely logical standpoint.
  $operation_handler = new $handler_class($entity_type);
  $operation_access = $operation_handler->operationAccess($entity_type, $entity);
  // If something non-NULL was returned, it has precedence.
  if (isset($operation_access)) {
    return $operation_access;
  }

  // If something non-NULL was returned, it has precedence.
  $user_access = $operation_handler->userAccess($entity_type, $entity);
  if (isset($user_access)) {
    return $user_access;
  }

  // Otherwise, let entity access take over.
  // Note that while entity_access() documents itself as only supporting
  // basic values of $op, in fact it just passes them to the access
  // callback, meaning that as long as your entity's access callback
  // understands it, you can do it here.
  $verb = $operation_handler->access_verb;
  $access = entity_access($operation_handler->access_verb, $entity_type);

  return $access;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function entity_operations_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'views_bulk_operations') {
    return 'plugins/' . $plugin_type;
  }
}
